// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package whirlpool

import (
	"encoding/json"
	"errors"
	"fmt"
	ag_jsonrpc "github.com/gagliardetto/solana-go/rpc/jsonrpc"
)

var (
	_ *json.Encoder        = nil
	_ *ag_jsonrpc.RPCError = nil
	_ fmt.Formatter        = nil
	_                      = errors.ErrUnsupported
)
var (
	ErrInvalidEnum = &customErrorDef{
		code: 6000,
		msg:  "Enum value could not be converted",
		name: "InvalidEnum",
	}
	ErrInvalidStartTick = &customErrorDef{
		code: 6001,
		msg:  "Invalid start tick index provided.",
		name: "InvalidStartTick",
	}
	ErrTickArrayExistInPool = &customErrorDef{
		code: 6002,
		msg:  "Tick-array already exists in this whirlpool",
		name: "TickArrayExistInPool",
	}
	ErrTickArrayIndexOutofBounds = &customErrorDef{
		code: 6003,
		msg:  "Attempt to search for a tick-array failed",
		name: "TickArrayIndexOutofBounds",
	}
	ErrInvalidTickSpacing = &customErrorDef{
		code: 6004,
		msg:  "Tick-spacing is not supported",
		name: "InvalidTickSpacing",
	}
	ErrClosePositionNotEmpty = &customErrorDef{
		code: 6005,
		msg:  "Position is not empty It cannot be closed",
		name: "ClosePositionNotEmpty",
	}
	ErrDivideByZero = &customErrorDef{
		code: 6006,
		msg:  "Unable to divide by zero",
		name: "DivideByZero",
	}
	ErrNumberCastError = &customErrorDef{
		code: 6007,
		msg:  "Unable to cast number into BigInt",
		name: "NumberCastError",
	}
	ErrNumberDownCastError = &customErrorDef{
		code: 6008,
		msg:  "Unable to down cast number",
		name: "NumberDownCastError",
	}
	ErrTickNotFound = &customErrorDef{
		code: 6009,
		msg:  "Tick not found within tick array",
		name: "TickNotFound",
	}
	ErrInvalidTickIndex = &customErrorDef{
		code: 6010,
		msg:  "Provided tick index is either out of bounds or uninitializable",
		name: "InvalidTickIndex",
	}
	ErrSqrtPriceOutOfBounds = &customErrorDef{
		code: 6011,
		msg:  "Provided sqrt price out of bounds",
		name: "SqrtPriceOutOfBounds",
	}
	ErrLiquidityZero = &customErrorDef{
		code: 6012,
		msg:  "Liquidity amount must be greater than zero",
		name: "LiquidityZero",
	}
	ErrLiquidityTooHigh = &customErrorDef{
		code: 6013,
		msg:  "Liquidity amount must be less than i64::MAX",
		name: "LiquidityTooHigh",
	}
	ErrLiquidityOverflow = &customErrorDef{
		code: 6014,
		msg:  "Liquidity overflow",
		name: "LiquidityOverflow",
	}
	ErrLiquidityUnderflow = &customErrorDef{
		code: 6015,
		msg:  "Liquidity underflow",
		name: "LiquidityUnderflow",
	}
	ErrLiquidityNetError = &customErrorDef{
		code: 6016,
		msg:  "Tick liquidity net underflowed or overflowed",
		name: "LiquidityNetError",
	}
	ErrTokenMaxExceeded = &customErrorDef{
		code: 6017,
		msg:  "Exceeded token max",
		name: "TokenMaxExceeded",
	}
	ErrTokenMinSubceeded = &customErrorDef{
		code: 6018,
		msg:  "Did not meet token min",
		name: "TokenMinSubceeded",
	}
	ErrMissingOrInvalidDelegate = &customErrorDef{
		code: 6019,
		msg:  "Position token account has a missing or invalid delegate",
		name: "MissingOrInvalidDelegate",
	}
	ErrInvalidPositionTokenAmount = &customErrorDef{
		code: 6020,
		msg:  "Position token amount must be 1",
		name: "InvalidPositionTokenAmount",
	}
	ErrInvalidTimestampConversion = &customErrorDef{
		code: 6021,
		msg:  "Timestamp should be convertible from i64 to u64",
		name: "InvalidTimestampConversion",
	}
	ErrInvalidTimestamp = &customErrorDef{
		code: 6022,
		msg:  "Timestamp should be greater than the last updated timestamp",
		name: "InvalidTimestamp",
	}
	ErrInvalidTickArraySequence = &customErrorDef{
		code: 6023,
		msg:  "Invalid tick array sequence provided for instruction.",
		name: "InvalidTickArraySequence",
	}
	ErrInvalidTokenMintOrder = &customErrorDef{
		code: 6024,
		msg:  "Token Mint in wrong order",
		name: "InvalidTokenMintOrder",
	}
	ErrRewardNotInitialized = &customErrorDef{
		code: 6025,
		msg:  "Reward not initialized",
		name: "RewardNotInitialized",
	}
	ErrInvalidRewardIndex = &customErrorDef{
		code: 6026,
		msg:  "Invalid reward index",
		name: "InvalidRewardIndex",
	}
	ErrRewardVaultAmountInsufficient = &customErrorDef{
		code: 6027,
		msg:  "Reward vault requires amount to support emissions for at least one day",
		name: "RewardVaultAmountInsufficient",
	}
	ErrFeeRateMaxExceeded = &customErrorDef{
		code: 6028,
		msg:  "Exceeded max fee rate",
		name: "FeeRateMaxExceeded",
	}
	ErrProtocolFeeRateMaxExceeded = &customErrorDef{
		code: 6029,
		msg:  "Exceeded max protocol fee rate",
		name: "ProtocolFeeRateMaxExceeded",
	}
	ErrMultiplicationShiftRightOverflow = &customErrorDef{
		code: 6030,
		msg:  "Multiplication with shift right overflow",
		name: "MultiplicationShiftRightOverflow",
	}
	ErrMulDivOverflow = &customErrorDef{
		code: 6031,
		msg:  "Muldiv overflow",
		name: "MulDivOverflow",
	}
	ErrMulDivInvalidInput = &customErrorDef{
		code: 6032,
		msg:  "Invalid div_u256 input",
		name: "MulDivInvalidInput",
	}
	ErrMultiplicationOverflow = &customErrorDef{
		code: 6033,
		msg:  "Multiplication overflow",
		name: "MultiplicationOverflow",
	}
	ErrInvalidSqrtPriceLimitDirection = &customErrorDef{
		code: 6034,
		msg:  "Provided SqrtPriceLimit not in the same direction as the swap.",
		name: "InvalidSqrtPriceLimitDirection",
	}
	ErrZeroTradableAmount = &customErrorDef{
		code: 6035,
		msg:  "There are no tradable amount to swap.",
		name: "ZeroTradableAmount",
	}
	ErrAmountOutBelowMinimum = &customErrorDef{
		code: 6036,
		msg:  "Amount out below minimum threshold",
		name: "AmountOutBelowMinimum",
	}
	ErrAmountInAboveMaximum = &customErrorDef{
		code: 6037,
		msg:  "Amount in above maximum threshold",
		name: "AmountInAboveMaximum",
	}
	ErrTickArraySequenceInvalidIndex = &customErrorDef{
		code: 6038,
		msg:  "Invalid index for tick array sequence",
		name: "TickArraySequenceInvalidIndex",
	}
	ErrAmountCalcOverflow = &customErrorDef{
		code: 6039,
		msg:  "Amount calculated overflows",
		name: "AmountCalcOverflow",
	}
	ErrAmountRemainingOverflow = &customErrorDef{
		code: 6040,
		msg:  "Amount remaining overflows",
		name: "AmountRemainingOverflow",
	}
	ErrInvalidIntermediaryMint = &customErrorDef{
		code: 6041,
		msg:  "Invalid intermediary mint",
		name: "InvalidIntermediaryMint",
	}
	ErrDuplicateTwoHopPool = &customErrorDef{
		code: 6042,
		msg:  "Duplicate two hop pool",
		name: "DuplicateTwoHopPool",
	}
	ErrInvalidBundleIndex = &customErrorDef{
		code: 6043,
		msg:  "Bundle index is out of bounds",
		name: "InvalidBundleIndex",
	}
	ErrBundledPositionAlreadyOpened = &customErrorDef{
		code: 6044,
		msg:  "Position has already been opened",
		name: "BundledPositionAlreadyOpened",
	}
	ErrBundledPositionAlreadyClosed = &customErrorDef{
		code: 6045,
		msg:  "Position has already been closed",
		name: "BundledPositionAlreadyClosed",
	}
	ErrPositionBundleNotDeletable = &customErrorDef{
		code: 6046,
		msg:  "Unable to delete PositionBundle with open positions",
		name: "PositionBundleNotDeletable",
	}
	ErrUnsupportedTokenMint = &customErrorDef{
		code: 6047,
		msg:  "Token mint has unsupported attributes",
		name: "UnsupportedTokenMint",
	}
	ErrRemainingAccountsInvalidSlice = &customErrorDef{
		code: 6048,
		msg:  "Invalid remaining accounts",
		name: "RemainingAccountsInvalidSlice",
	}
	ErrRemainingAccountsInsufficient = &customErrorDef{
		code: 6049,
		msg:  "Insufficient remaining accounts",
		name: "RemainingAccountsInsufficient",
	}
	ErrNoExtraAccountsForTransferHook = &customErrorDef{
		code: 6050,
		msg:  "Unable to call transfer hook without extra accounts",
		name: "NoExtraAccountsForTransferHook",
	}
	ErrIntermediateTokenAmountMismatch = &customErrorDef{
		code: 6051,
		msg:  "Output and input amount mismatch",
		name: "IntermediateTokenAmountMismatch",
	}
	ErrTransferFeeCalculationError = &customErrorDef{
		code: 6052,
		msg:  "Transfer fee calculation failed",
		name: "TransferFeeCalculationError",
	}
	ErrRemainingAccountsDuplicatedAccountsType = &customErrorDef{
		code: 6053,
		msg:  "Same accounts type is provided more than once",
		name: "RemainingAccountsDuplicatedAccountsType",
	}
	ErrFullRangeOnlyPool = &customErrorDef{
		code: 6054,
		msg:  "This whirlpool only supports full-range positions",
		name: "FullRangeOnlyPool",
	}
	ErrTooManySupplementalTickArrays = &customErrorDef{
		code: 6055,
		msg:  "Too many supplemental tick arrays provided",
		name: "TooManySupplementalTickArrays",
	}
	ErrDifferentWhirlpoolTickArrayAccount = &customErrorDef{
		code: 6056,
		msg:  "TickArray account for different whirlpool provided",
		name: "DifferentWhirlpoolTickArrayAccount",
	}
	ErrPartialFillError = &customErrorDef{
		code: 6057,
		msg:  "Trade resulted in partial fill",
		name: "PartialFillError",
	}
	ErrPositionNotLockable = &customErrorDef{
		code: 6058,
		msg:  "Position is not lockable",
		name: "PositionNotLockable",
	}
	ErrOperationNotAllowedOnLockedPosition = &customErrorDef{
		code: 6059,
		msg:  "Operation not allowed on locked position",
		name: "OperationNotAllowedOnLockedPosition",
	}
	ErrSameTickRangeNotAllowed = &customErrorDef{
		code: 6060,
		msg:  "Cannot reset position range with same tick range",
		name: "SameTickRangeNotAllowed",
	}
	ErrInvalidAdaptiveFeeConstants = &customErrorDef{
		code: 6061,
		msg:  "Invalid adaptive fee constants",
		name: "InvalidAdaptiveFeeConstants",
	}
	ErrInvalidFeeTierIndex = &customErrorDef{
		code: 6062,
		msg:  "Invalid fee tier index",
		name: "InvalidFeeTierIndex",
	}
	ErrInvalidTradeEnableTimestamp = &customErrorDef{
		code: 6063,
		msg:  "Invalid trade enable timestamp",
		name: "InvalidTradeEnableTimestamp",
	}
	ErrTradeIsNotEnabled = &customErrorDef{
		code: 6064,
		msg:  "Trade is not enabled yet",
		name: "TradeIsNotEnabled",
	}
	Errors = map[int]CustomError{
		6000: ErrInvalidEnum,
		6001: ErrInvalidStartTick,
		6002: ErrTickArrayExistInPool,
		6003: ErrTickArrayIndexOutofBounds,
		6004: ErrInvalidTickSpacing,
		6005: ErrClosePositionNotEmpty,
		6006: ErrDivideByZero,
		6007: ErrNumberCastError,
		6008: ErrNumberDownCastError,
		6009: ErrTickNotFound,
		6010: ErrInvalidTickIndex,
		6011: ErrSqrtPriceOutOfBounds,
		6012: ErrLiquidityZero,
		6013: ErrLiquidityTooHigh,
		6014: ErrLiquidityOverflow,
		6015: ErrLiquidityUnderflow,
		6016: ErrLiquidityNetError,
		6017: ErrTokenMaxExceeded,
		6018: ErrTokenMinSubceeded,
		6019: ErrMissingOrInvalidDelegate,
		6020: ErrInvalidPositionTokenAmount,
		6021: ErrInvalidTimestampConversion,
		6022: ErrInvalidTimestamp,
		6023: ErrInvalidTickArraySequence,
		6024: ErrInvalidTokenMintOrder,
		6025: ErrRewardNotInitialized,
		6026: ErrInvalidRewardIndex,
		6027: ErrRewardVaultAmountInsufficient,
		6028: ErrFeeRateMaxExceeded,
		6029: ErrProtocolFeeRateMaxExceeded,
		6030: ErrMultiplicationShiftRightOverflow,
		6031: ErrMulDivOverflow,
		6032: ErrMulDivInvalidInput,
		6033: ErrMultiplicationOverflow,
		6034: ErrInvalidSqrtPriceLimitDirection,
		6035: ErrZeroTradableAmount,
		6036: ErrAmountOutBelowMinimum,
		6037: ErrAmountInAboveMaximum,
		6038: ErrTickArraySequenceInvalidIndex,
		6039: ErrAmountCalcOverflow,
		6040: ErrAmountRemainingOverflow,
		6041: ErrInvalidIntermediaryMint,
		6042: ErrDuplicateTwoHopPool,
		6043: ErrInvalidBundleIndex,
		6044: ErrBundledPositionAlreadyOpened,
		6045: ErrBundledPositionAlreadyClosed,
		6046: ErrPositionBundleNotDeletable,
		6047: ErrUnsupportedTokenMint,
		6048: ErrRemainingAccountsInvalidSlice,
		6049: ErrRemainingAccountsInsufficient,
		6050: ErrNoExtraAccountsForTransferHook,
		6051: ErrIntermediateTokenAmountMismatch,
		6052: ErrTransferFeeCalculationError,
		6053: ErrRemainingAccountsDuplicatedAccountsType,
		6054: ErrFullRangeOnlyPool,
		6055: ErrTooManySupplementalTickArrays,
		6056: ErrDifferentWhirlpoolTickArrayAccount,
		6057: ErrPartialFillError,
		6058: ErrPositionNotLockable,
		6059: ErrOperationNotAllowedOnLockedPosition,
		6060: ErrSameTickRangeNotAllowed,
		6061: ErrInvalidAdaptiveFeeConstants,
		6062: ErrInvalidFeeTierIndex,
		6063: ErrInvalidTradeEnableTimestamp,
		6064: ErrTradeIsNotEnabled,
	}
)

type CustomError interface {
	Code() int
	Name() string
	Error() string
}

type customErrorDef struct {
	code int
	name string
	msg  string
}

func (e *customErrorDef) Code() int {
	return e.code
}

func (e *customErrorDef) Name() string {
	return e.name
}

func (e *customErrorDef) Error() string {
	return fmt.Sprintf("%s(%d): %s", e.name, e.code, e.msg)
}

func DecodeCustomError(rpcErr error) (err error, ok bool) {
	if errCode, o := decodeErrorCode(rpcErr); o {
		if customErr, o := Errors[errCode]; o {
			err = customErr
			ok = true
			return
		}
	}
	return
}

func decodeErrorCode(rpcErr error) (errorCode int, ok bool) {
	var jErr *ag_jsonrpc.RPCError
	if errors.As(rpcErr, &jErr) && jErr.Data != nil {
		if root, o := jErr.Data.(map[string]interface{}); o {
			if rootErr, o := root["err"].(map[string]interface{}); o {
				if rootErrInstructionError, o := rootErr["InstructionError"]; o {
					if rootErrInstructionErrorItems, o := rootErrInstructionError.([]interface{}); o {
						if len(rootErrInstructionErrorItems) == 2 {
							if v, o := rootErrInstructionErrorItems[1].(map[string]interface{}); o {
								if v2, o := v["Custom"].(json.Number); o {
									if code, err := v2.Int64(); err == nil {
										ok = true
										errorCode = int(code)
									}
								} else if v2, o := v["Custom"].(float64); o {
									ok = true
									errorCode = int(v2)
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
